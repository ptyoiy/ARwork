<!DOCTYPE html>

<head>
	<title>AR Interior</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<style>
	ol {
		padding-left: 4em;
	}

	.label {
		text-shadow: -1px 1px 1px rgb(0, 0, 0);
		font-size: 20px;
		position: absolute;
	}
</style>

<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script type="module">
	// https://immersive-web.github.io/webxr-samples/ 사용법 예제들 #필수참조#
	import * as THREE from '../build/three.module.js'; // Three.js 사용
	import { GUI } from "./jsm/libs/dat.gui.module.js";
	import { WEBVR } from './js/vr/WebVR.js';
	import { ARButton } from './jsm/webxr/ARButton.js';

	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
	import { BufferGeometryUtils } from './jsm/utils/BufferGeometryUtils.js';


	// Three.js 변수 설정
	let container, labelContainer; // html에 추가할 코드를 담을 변수
	let camera, scene, renderer; // three.js 1단계 변수
	let controller; // 추가한 객체 그룹(원통 배열) 관리 ?
	let reticle; // 화면 중앙에 뜨는 생성 원

	// 빛(주변광+직사광)
	let light;
	let directionalLight;
	const API = {
		// lightProbeIntensity: 1.0,
		directionalLightIntensity: 0.2, // 밝기
		// envMapIntensity: 1
	};

	// hitTest API에서 사용
	let hitTestSource = null;
	let hitTestSourceRequested = false;
	let xrTransientInputHitTestSource = null;
	let xrRefSpace = null;

	// 거리측정에서 사용
	let measurements = [];
	let labels = [];
	let currentLine = null;
	let width, height;

	// 옵션박스에서 사용
	let config; // 옵션 변수
	let path; // 3D 모델 경로
	let gltfLoader = new GLTFLoader(); // 3D 모델 관리자
	let mesh; // 3D모델
	let make = 0; // 0 = 해제, 1 = 잠금 
	let pickableMeshes = []; // 선택용 배열

	let pickedObj;
	let pickedObjId;
	let pickedObjPrt;
	// 제어판 터치시엔 select이벤트 발생 무시
	let set = false; // -> true가 되면 제어판영역 터치한것
	$(document).click(function (evt) { // 클릭한것이 옵션박스의 태그면 set을 true만듬
		var target = evt.originalEvent.target;
		console.log(target.nodeName);
		if (target.nodeName == "UL" || target.nodeName == "LI" || target.nodeName == "SELECT" || target.nodeName == "INPUT" || target.nodeName == "SPAN") {
			set = true;
		}
		else if (target.nodeName == "DIV") { // close / open 버튼전용
			set = true;
			setTimeout(function () { // close/open 누르고 0.5초 뒤 set false로 변경
				set = false;
				console.log("1");
			}, 500);
		}
		else
			set = false;
	});
	// close/open버튼 전용
	$(document).mouseup(function (evt) {
		var target = evt.originalEvent.target;
		if (target.nodeName == "DIV") {
			setTimeout(function () {
				set = false;
				console.log("2");

			}, 500);
		}
	});

	// 물체 선택(raycaster) 클래스
	class PickHelper {
		constructor() {
			//레이캐스터
			this.raycaster = new THREE.Raycaster();

			// 선택한 물체
			this.pickedObject = null;
			this.befObjId = null;
			this.obj = null;
			this.parent = null;

			// 선택된 물체의 색
			this.pickedObjectSavedMaterial = null;
			this.selectMaterial = new THREE.MeshBasicMaterial();

		}
		
		pick(normalizedPosition, scene, camera, time) {
			// 광선의 방향 설정(원점, 끝점)
			this.raycaster.set(this.raycaster.ray.origin, normalizedPosition.normalize());

			// 선택물체 업데이트를 위한 데이터초기화 
			if (this.pickedObject) {
				this.pickedObject.material = this.pickedObjectSavedMaterial; 
				this.pickedObject = undefined;
			// 	this.obj = undefined;
			// 	this.parent = undefined;
			}// 
			// 광선에 닿은 모든 물체 저장
			const intersectedObjects = this.raycaster.intersectObjects(pickableMeshes, true);
			if (intersectedObjects.length) {
				// 닿은것 중 가장 가까운 물체 저장
				this.pickedObject = intersectedObjects[0].object;
				// 물체의 id, parent(계층구조) 저장 -> 제거에 사용 
					
				this.obj = this.pickedObject.id;
				this.parent = this.pickedObject.parent;
				// 원본 Material저장
				this.pickedObjectSavedMaterial = this.pickedObject.material;  //
				this.pickedObject.material = this.selectMaterial;
				// 빨강/노랑으로 반짝임 
				this.selectMaterial.color.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);

				
				pickedObjId = this.getPickedObjId();
				pickedObjPrt = this.getPickedObjPrt();
			}
		}
		
		getPickedObj(){
			return this.pickedObject;
		}
		getPickedObjId(){
			return this.obj;
		}
		getPickedObjPrt(){
			return this.parent;
		}
		getPickedSavedObj(){
			return this.pickedObjectSavedMaterial;
		}

		setPickedMatetial(){
			this.pickedObject.material = this.pickedObjectSavedMaterial;
			console.log("setpickedMatetial 작동");
		} 
		setPickedObj(){
			this.pickedObject = undefined;
		}
		setPickedObjId(){
			this.obj = undefined;
		}
		setPickedObjPrt(){
			this.parent = undefined;
		}
	}
	// 함수 정의
	function init() {
		// <div class="container"> 생성 -> html에 그려낼 공간 생성
		container = document.createElement('div');
		document.body.appendChild(container);
		width = window.innerWidth;
		height = window.innerHeight;
		// 2단계/씬+카메라
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);

		// 2단계/빛(x,y,z 세 방향 추가)
		// x y z
		AddLights(100, 0, 0); AddLights(0, 100, 0); AddLights(0, 0, 100);

		// 옵션박스실행
		setupGui();

		// 1단계/렌더러
		renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // 3d 렌더링 관리자
		renderer.setPixelRatio(window.devicePixelRatio); // 픽셀 갯수 자동
		renderer.setSize(window.innerWidth, window.innerHeight); // 창 크기에 맞게
		renderer.xr.enabled = true; // WebXR 필수 3
		container.appendChild(renderer.domElement); // <div class="container"> 에 1단계/렌더러에서 만든 renderer내용 추가
		initLabelContainer()
		container.appendChild(labelContainer);

		initReticle(); // 생성 원 초기화
		scene.add(reticle); // 생성 원 추가

		document.body.appendChild(ARButton.createButton(renderer, {
			optionalFeatures: ["dom-overlay", "anchors"],
			domOverlay: { root: document.body },
			requiredFeatures: ['hit-test']
		}));

		// AR 세션 시작 - dom-overlay에 불필요한 개체 제거
		renderer.xr.addEventListener('sessionstart',
			function (ev) {
				console.log('sessionstart', ev);
				document.body.style.backgroundColor = 'rgba(0, 0, 0, 0)';
				renderer.domElement.style.display = 'none';
			});
		// 세션 끝
		renderer.xr.addEventListener('sessionend',
			function (ev) {
				console.log('sessionend', ev);
				document.body.style.backgroundColor = '';
				renderer.domElement.style.display = '';
			});

		window.addEventListener('resize', onWindowResize, false); // 화면크기변화에 반응
		animate()
	}
	// init end 

	// 옵션 박스 
	function setupGui() {
		config = {
			obj: "sunflower",
			mode: "interior",
			x: 0,
			y: 0,
			z: 0,
			px: 0,
			py: 0,
			pz: 0,

			del: false,
			sel: false
		};
		path = "./media/" + config.obj + "/" + config.obj + ".gltf"; // 초기화
		const gui = new GUI();

		var h = gui.addFolder("물체");
		h.add(config, "obj", ["none", "sunflower", "reticle", "park_table", "metal_table"]).name("물체").onChange(function (val) {
			make = 0;
			path = "./media/" + val + "/" + val + ".gltf";
			scene.remove(reticle);
			initReticle();
			scene.add(reticle);
			set = false;
			// console.log("set:" + set);
		}).listen();
		h.open();

		var h = gui.addFolder("회전");
		h.add(config, "x", 0.0, 6.28, 0.04).name("x").onChange(function (val) {
			mesh.rotation.x = val;
		}).listen();
		h.add(config, "y", 0.0, 6.28, 0.04).name("y").onChange(function (val) {
			mesh.rotation.y = val;
		}).listen();
		h.add(config, "z", 0.0, 6.28, 0.04).name("z").onChange(function (val) {
			mesh.rotation.z = val;
		}).listen();

		
		var item_del;
		var item_sel;
		var del_ = false;
		var h = gui.addFolder("모드");
		h.add(config, "mode", ["interior", "select", "measurement"]).name("mode").onChange(function (val) {
			if (del_){
				h.remove(item_del);
				h.remove(item_sel);
				del_ = false;
				config.sel = false;
			}// 
			scene.remove(reticle);
			initReticle();
			scene.add(reticle);
			
			/*  
				십자선 코드 얻어다가 initReticle 가셔서 else if (interior) / else if (select) 구별해서 만드십셔
				mode = select로 시작하고, 시작하자마자 광선 쏘고, 물체 투사하면 반짝이고,// 여까지 댔고   
				여기서 onselect가 실행되면 원판 사라지며 config.sel = true //
				 이후 버튼 누르면(=config.sel = false)가 되고 다시 광선 				
			*/
			if (val == "select") {
				
				if (!del_){
					item_del = h.add(config, "del").name("삭제").onChange(function (val) {
						// todo delete...
					
						if (pickedObjId) {
							// 선택된 물체의 id값을 가진 물체를 scene.children(this.parent)에서 찾아 제거
							pickedObjPrt.remove(scene.getObjectById(pickedObjId));
							// 물체선택용 배열도 동일하게 제거
							for (var i = 0; i < pickableMeshes.length; i++) {
								if (pickableMeshes[i].id == pickedObjId) {
									// console.log("발견");
									// console.log(pickableMeshes.length);
									pickableMeshes.splice(i, 1);// 배열의 i번째에서 1개만큼 제거
									break;
								}
							}
							config.del = false;
							pickHelper.setPickedObj();
							pickHelper.setPickedObjId();
							pickHelper.setPickedObjPrt();
						}
						// 제거 후 선택데이터 초기화
					}).listen();

					item_sel = h.add(config, "sel").name("이동").onChange(function (val) {
						// todo end...
					}).listen();
					del_ = true;
				}

			}
			
			set = false;
		}).listen(); // 이동종료 버튼 -> 1~5 중 2,3번 흐름에서 원판을 제거하며 config.sel을 true로 변경
	}; // 완성 ( 선택모드 변경시 삭제와 이동종료버튼 표시됨 / 다른 모드 변경시 버튼들 제거됨)
	
	// glTF 피킹용 박스 생성
	function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
		const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
		const halfFovY = THREE.Math.degToRad(camera.fov * .5);
		const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
		// compute a unit vector that points in the direction the camera is now
		// in the xz plane from the center of the box
		const direction = (new THREE.Vector3())
			.subVectors(camera.position, boxCenter)
			.multiply(new THREE.Vector3(1, 0, 1))
			.normalize();

		// move the camera to a position distance units way from the center
		// in whatever direction the camera was from the center already
		camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

		// pick some near and far values for the frustum that
		// will contain the box.
		camera.near = boxSize / 100;
		camera.far = boxSize * 100;

		camera.updateProjectionMatrix();

		// point the camera to look at the center of the box
		camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
	}

	// 광원 추가
	function AddLights(x, y, z) {
		light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
		light.position.set(x, y, z);
		scene.add(light);
		directionalLight = new THREE.DirectionalLight(0xffffff, API.directionalLightIntensity);
		directionalLight.position.set(x, y, z);
		scene.add(directionalLight);
	}

	// 원판 생성
	function initReticle() {
		let ring = new THREE.RingBufferGeometry(0.045, 0.05, 32).rotateX(- Math.PI / 2);
		let dot = new THREE.CircleBufferGeometry(0.005, 32).rotateX(- Math.PI / 2);
		let selected = new THREE.RingBufferGeometry(0.045, 0.055, 32).rotateZ(- Math.PI / 2);
		let cross= new THREE.CircleBufferGeometry(0.0075, 32).rotateZ(- Math.PI / 2);
	
		if (config.mode == "measurement") {
			reticle = new THREE.Mesh(
				BufferGeometryUtils.mergeBufferGeometries([ring, dot]),
				new THREE.MeshBasicMaterial() // 중앙에 점이 있는 원판
			);
		 }
		// else if (config.mode == "interior")
		else {
			reticle = new THREE.Mesh(
				new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(- Math.PI / 2),
				new THREE.MeshBasicMaterial() // 흰색, 원판 모양
			);
		}
		// else if (config.mode == "select"){ 
		// 	reticle = new THREE.Mesh(
		// 		BufferGeometryUtils.mergeBufferGeometries([selected, cross]),
		// 		new THREE.MeshBasicMaterial()
		// 	)
			

		// }

		reticle.matrixAutoUpdate = false;
		reticle.visible = false;
	}

	// 화면크기변화에 반응
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	// 루프
	function animate() {
		renderer.setAnimationLoop(render); //WebXR 필수 4(끝)
	}

	// cm표기할 label 생성(거리측정)
	function initLabelContainer() {
		labelContainer = document.createElement('div');
		labelContainer.style.position = 'absolute';
		labelContainer.style.top = '0px';
		labelContainer.style.pointerEvents = 'none';
		labelContainer.setAttribute('id', 'container');
	}

	// line의 길이 계산
	function getDistance(points) {
		if (points.length == 2)
			return points[0].distanceTo(points[1]);
	}

	// line 길이 업데이트
	function updateLine(matrix) {
		let positions = currentLine.geometry.attributes.position.array;
		positions[3] = matrix.elements[12]
		positions[4] = matrix.elements[13]
		positions[5] = matrix.elements[14]
		currentLine.geometry.attributes.position.needsUpdate = true;
		currentLine.geometry.computeBoundingSphere();
	}

	// line 생성
	function initLine(point) {
		let lineMaterial = new THREE.LineBasicMaterial({
			color: 0xffffff,
			linewidth: 5,
			linecap: 'round'
		});

		let lineGeometry = new THREE.BufferGeometry().setFromPoints([point, point]);
		return new THREE.Line(lineGeometry, lineMaterial);
	}

	// line의 중간위치 계산
	function getCenterPoint(points) {
		let line = new THREE.Line3(...points)
		return line.getCenter();
	}

	// Hit_test좌표데이터(16개) -> xyz(3개)로 정규화
	function matrixToVector(matrix) {
		let vector = new THREE.Vector3();
		vector.setFromMatrixPosition(matrix);
		return vector;
	}

	// 길이를 표기할 라벨의 화면에서의 위치 계산
	function toScreenPosition(point, camera) {
		var vector = new THREE.Vector3();

		vector.copy(point);
		vector.project(camera);

		vector.x = (vector.x + 1) * width / 2;
		vector.y = (-vector.y + 1) * height / 2 + 40;
		vector.z = 0;

		return vector

	};

 	function onSelect(event) {

	if (!set) {

		switch (config.mode) {
			case "interior":
				if (reticle.visible && make == 0) { // 생성 원이 보일때만 생성 
					make = 1;
					gltfLoader.load(path, (gltf) => {
						mesh = gltf.scene
						mesh.position.setFromMatrixPosition(reticle.matrix); //위치
						// 앵커로 생성
						if (hitTestSource) {
							let results = event.frame.getHitTestResults(hitTestSource);
							// Use the results to place our proxy object.
							if (results.length) {
								let hitResult = results[0];
								// addARObjectAt(event.frame, hitResult); // hitResult = 힛테스트 좌표 ( 좌표에 오브젝트 추가 )
							}
						}

						function addARObjectAt(frame, hitTestResult) {
							// 앵커방식 사용
							if ("createAnchor" in hitTestResult) {
								hitTestResult.createAnchor(new XRRigidTransform())
									.then(onCreateAnchor)
									.catch((err) => console.log("Anchor creation failed", err));
								// alert("앵커씀");
							}
						}
						function onCreateAnchor(anchor) {
							console.debug("Anchor created");
							anchor.context = {};
							// let sceneObject = arObject.clone();
							// sceneObject.visible = false;

							// 
							// flowers.push(sceneObject);// 선 생성
							anchor.context.mesh = mesh;
							mesh.anchor = anchor;// 후 설정(=좌표설정)
						}
						// ~~
						scene.add(mesh);
						path = null;
						// scene.add(mesh); // 추가
						console.log(mesh.id);
						// 추가한 3D 물체를 선택하기 위해 상자생성
						const box = new THREE.Box3().setFromObject(mesh);
						const boxSize = box.getSize(new THREE.Vector3()).length();
						const boxCenter = box.getCenter(new THREE.Vector3());

						// set the camera to frame the box
						frameArea(boxSize * 0.7, boxSize, boxCenter, camera);

						// get a list of all the meshes in the scen
						mesh.traverse((node) => {
							if (node instanceof THREE.Mesh) {
								pickableMeshes.push(node);
							}
						});
						// 정보 업데이트
						config.x = mesh.rotation.x; config.y = mesh.rotation.y; config.z = mesh.rotation.z;
						config.px = mesh.position.x; config.py = mesh.position.y; config.pz = mesh.position.z;
						config.obj = "none";
					});
				}

				break;
			case "measurement":
				if (reticle.visible) {
					measurements.push(matrixToVector(reticle.matrix));
					if (measurements.length == 2) {
						let distance = Math.round(getDistance(measurements) * 100);

						let text = document.createElement('div');
						text.className = 'label';
						text.style.color = 'rgb(255,255,255)';
						text.textContent = distance + ' cm';
						document.querySelector('#container').appendChild(text);

						labels.push({ div: text, point: getCenterPoint(measurements) });

						measurements = [];
						currentLine = null;

						console.log(text.textContent);
					} else {
						currentLine = initLine(measurements[0]);
						scene.add(currentLine);
					}
				}
				break;
			case "select":
				if (!config.sel&&(pickedObj!=undefined||pickedObj!=null)) {
					// 터치좌표로 이동
					config.sel= true;
					pickedObj = pickHelper.getPickedObj();
					
				}
				else {
					config.sel= false;
				}
				console.log(config.mode);
				break;


			default:
				console.log("error");
				console.log(config.mode);
				break;
		}
	}
};
	/*
	- WebXR 기본 App동작 프로세스

	1) XR Device 요청
	2) Device 사용 가능한 경우 XR Session 요청. 폰이 헤드셋이 된 경우 immersive session이라 불리며 사용자의 gesture가 들어간다.
	3) Rendering Loop를 실행하기 위해 Session을 사용 (60fps). 각 프레임마다 해당하는 내용물을 그림
	4) Rendering Loop를 실행 (사용자 종료까지)
	5) XR Session 종료
	
	- Interaction
	
	"Point and Click" (가르키고, 선택)
	
	=> pointer ray : Input Device가 가리키는 "위치"와 무언가 선택하는 "이벤트"를 감지하기 위해 정의.
	가리키는 곳을 pointer ray가 그리고 보여준다.
	클릭하면 이벤트 발생 : select, selectStart, selectEnd..
	*/

	let all_previous_anchors = new Set();
	let pos={x:0, y:0, z:0};
	function render(timestamp, frame) {
		timestamp *= 0.001;
		if (frame) {
			let referenceSpace = renderer.xr.getReferenceSpace();
			let session = renderer.xr.getSession();

			// local Space얻기 (Hit Test는 viewer Space)
			session.requestReferenceSpace('local').then((refSpace) => {
				xrRefSpace = refSpace;
			});
			// event값 얻기위한 session에서 이벤트 감지
			session.addEventListener('select', onSelect);

			// 힛테스트값 얻기
			if (hitTestSourceRequested === false) {
				session.requestReferenceSpace('viewer').then(function (referenceSpace) {
					session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
						hitTestSource = source;
					});
				});
				session.addEventListener('end', function () {
					hitTestSourceRequested = false;
					hitTestSource = null;
				});
				hitTestSourceRequested = true;
			}
			if (hitTestSource) {
				let hitTestResults = frame.getHitTestResults(hitTestSource);
				if (hitTestResults.length) {
					let hit = hitTestResults[0];
					reticle.visible = true;
					reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
					pos.x = hit.getPose(referenceSpace).transform.matrix[12];
					pos.y = hit.getPose(referenceSpace).transform.matrix[13]*0.5;
					pos.z = hit.getPose(referenceSpace).transform.matrix[14];
					if (config.mode == "select") { // 쓸데없는 계산을 방지
						pickHelper.pick(matrixToVector(reticle.matrix), scene, camera, timestamp);
					}
				} else {
					reticle.visible = false;
				}

				if (currentLine) {
					updateLine(reticle.matrix);
				}
			}
			if(config.mode =="select" && config.sel&& pickedObj){
				pickedObj.position.x=pos.x;
				pickedObj.position.y=pos.y;
				pickedObj.position.z=pos.z;
				console.log("on");

			}
			labels.map((label) => {
				let pos = toScreenPosition(label.point, renderer.xr.getCamera(camera));
				let x = pos.x;
				let y = pos.y;
				label.div.style.transform = "translate(-50%, -50%) translate(" + x + "px," + y + "px)";
			})

		}
		renderer.render(scene, camera);
	}

	init();
	const pickHelper = new PickHelper();

	/*
		1. 원판으로 선택(기존과 동일)
		2. 선택한 물체가 반짝일것 -> 한번 더 터치시 물체 선택되게
		3. 터치로 이동가능
		4. 이동끝은 어떻게?
			4-1 버튼만들어서 이동중지시킴 -> 버튼생성으로 끝 -----어플상 이게 더 많긴 함 - k의 작업
		5. 이동 종료시 다시 원판 생성, 1번부터 반복
		
		
		else if (!useReticle.checked && xrTransientInputHitTestSource) {
        let results_by_input_source = frame.getHitTestResultsForTransientInput(xrTransientInputHitTestSource);
        if (results_by_input_source.length && results_by_input_source[0].results.length) {
          let hitResult = results_by_input_source[0].results[0];//터치한 좌표 데이터
          arObject.visible = true;
          arObject.matrix = hitResult.getPose(xrRefSpace).transform.matrix; // 터치위치 좌표데이터 -> xyz로 변환
        } else {
          arObject.visible = false;
        }
      } else {
		arObject.visible = false;
	  }
	  
	*/
</script>


<body>
	<!-- 선택한 물체 알려줌 -->
	<!-- <div id="info"></div> -->
</body>

</html>